{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to My Public Vault","text":"<p>Welcome to my public personal knowledge hub, where I share insights, notes, and resources on software engineering, distributed systems and backend engineering. This vault is designed to help both myself and others learn and explore topics in depth. Please note that this knowledge hub is a work in progress and will be continuously updated with new insights and resources.</p>"},{"location":"#categories","title":"\ud83d\udccc Categories","text":"<p>[TODO]</p>"},{"location":"#how-to-navigate","title":"\ud83e\udded How to Navigate","text":"<p>Search: Use the search bar to find specific notes or topics. Links: Click on the links within each note to navigate to related topics or resources. Tags: Use tags to find related notes across different topics.</p>"},{"location":"#about-me-this-vault","title":"\ud83e\uddd1\ud83c\udffb About Me &amp; This Vault","text":"<p>My name is Kayode Oluwasegun, and I'm a Software Engineer. I am driven by a strategic mindset that enables me to identify patterns and devise forward-thinking solutions. With a future-oriented outlook, I am continually inspired to envision and share what could be possible, energizing others along the way.</p> <p>I am passionate about continuous learning and self-improvement, fascinated by ideas and the connections between seemingly disparate phenomena.</p> <p>As an achiever, I take immense satisfaction in being productive and completing tasks, which is reflected in the thoroughness and depth of the resources shared here. My effective communication skills help articulate complex ideas clearly, making this vault an enlightening resource for others. I promote a less stressful approach to development and enjoy deep, rewarding relationships, both personally and professionally.</p>"},{"location":"#contact-me","title":"\ud83d\udcec Contact Me","text":"<p>You can connect with me and follow my continuous learning journey on LinkedIn.</p>"},{"location":"reading/the-shelf/","title":"The Bookshop","text":"<p>Browse our curated collection of thought-provoking books.</p> 21 Lessons for the 21st Century <p>Yuval Noah Harari</p> History 1984 <p>George Orwell</p> Fiction Sapiens <p>Yuval Noah Harari</p> History The Hero With a Thousand Faces <p>Joseph Campbell</p> Mythology Cosmos <p>Carl Sagan</p> Science Meditations <p>Marcus Aurelius</p> Philosophy Man's Search for Meaning <p>Viktor E. Frankl</p> Psychology The God Delusion <p>Richard Dawkins</p> Philosophy The Denial of Death <p>Ernest Becker</p> Philosophy Between the World and Me <p>Ta-Nehisi Coates</p> Memoir The Lord of the Rings <p>J.R.R. Tolkien</p> Fantasy V for Vendetta <p>Alan Moore</p> Graphic Novel"},{"location":"reading/the-shelf/#recently-added","title":"Recently Added","text":"<p>Check back regularly for new additions to our collection.</p> <p>Total Books: 12 displayed | View All \u2192</p>"},{"location":"reading/books/read/the-go-programming-language/","title":"The GO Programming Language Exercises Solutions","text":""},{"location":"reading/books/read/the-go-programming-language/#chapter-1","title":"Chapter 1","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-11-modif-y-the-echo-program-to-also-print-osargs0-the-name-of-the-command-that-invoked-it","title":"Exercise 1.1 Modif y the echo program to also print os.Args[0], the name of the command that invoked it.","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    for i, arg := range os.Args {\n        if i &gt; 0 {\n            fmt.Print(\" \")\n        }\n        fmt.Print(arg)\n    }\n    fmt.Println()\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-12-modify-the-echo-program-to-print-the-index-and-value-of-each-of-its-arguments-one-per-line","title":"Exercise 1.2 Modify the echo program to print the index and value of each of its arguments, one per line.","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    for i, arg := range os.Args {\n        fmt.Println(i, arg)\n    }\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-13-exercise-13-experiment-to-measure-the-difference-in-running-time-between-our-potentially-inefficient-versions-and-the-one-that-uses-stringsjoin-section-16-illustrates-part-of-the-time-package-and-section-114-shows-how-to-write-benchmark-tests-for-systematic-per-formance-evaluation","title":"Exercise 1.3 Exercise 1.3: Experiment to measure the difference in running time between our potentially inefficient versions and the one that uses strings.Join. (Section 1.6 illustrates part of the time package, and Section 11.4 shows how to write benchmark tests for systematic per- formance evaluation.)","text":"<pre><code>package echo\n\nimport (\n    \"os\"\n    \"strings\"\n    \"testing\"\n)\n\nfunc echoConcat() string {\n    s := \"\"\n    for _, arg := range os.Args[1:] {\n        s += arg\n    }\n    return s\n}\n\nfunc echoJoin() string {\n    return strings.Join(os.Args[1:], \"\")\n}\n\nfunc BenchmarkEchoConcat(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        _ = echoConcat()\n    }\n}\n\nfunc BenchmarkEchoJoin(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        _ = echoJoin()\n    }\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-14-modif-y-dup2-to-print-the-names-of-all-files-in-which-each-duplicated-line-occurs","title":"Exercise 1.4: Modif y dup2 to print the names of all files in which each duplicated line occurs.","text":"<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    counts := make(map[string]int)\n    files := make(map[string]map[string]bool)\n\n    for _, name := range os.Args[1:] {\n        f, err := os.Open(name)\n        if err != nil {\n            continue\n        }\n        input := bufio.NewScanner(f)\n        for input.Scan() {\n            line := input.Text()\n            counts[line]++\n            if files[line] == nil {\n                files[line] = make(map[string]bool)\n            }\n            files[line][name] = true\n        }\n        f.Close()\n    }\n\n    for line, n := range counts {\n        if n &gt; 1 {\n            fmt.Print(n, \"\\t\", line)\n            for name := range files[line] {\n                fmt.Print(\"\\t\", name)\n            }\n            fmt.Println()\n        }\n    }\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-15-change-the-lissajous-programs-color-palette-to-green-on-black-for-added-authenticity-to-cre-ate-the-web-color-rrggbb-use-colorrgba0xrr-0xgg-0xbb-0xff-where-each-pair-of-hexadecimal-digits-represents-the-intensity-of-the-red-green-or-blue-component-of-the-pixel","title":"Exercise 1.5: Change the Lissajous program\u2019s color palette to green on black, for added authenticity. To cre ate the web color #RRGGBB, use color.RGBA{0xRR, 0xGG, 0xBB, 0xff}, where each pair of hexadecimal digits represents the intensity of the red, green, or blue component of the pixel.","text":"<pre><code>package main\n\nimport (\n    \"image\"\n    \"image/color\"\n    \"image/gif\"\n    \"math\"\n    \"math/rand\"\n    \"os\"\n)\n\nvar palette = []color.Color{\n    color.Black,\n    color.RGBA{255, 0, 0, 255},\n    color.RGBA{0, 255, 0, 255},\n    color.RGBA{0, 0, 255, 255},\n}\n\nconst (\n    whiteIndex = 0\n)\n\nfunc main() {\n    const (\n        cycles  = 5\n        res     = 0.001\n        size    = 100\n        nframes = 64\n        delay   = 8\n    )\n\n    freq := rand.Float64() * 3.0\n    anim := gif.GIF{LoopCount: nframes}\n    phase := 0.0\n    for i := 0; i &lt; nframes; i++ {\n        rect := image.Rect(0, 0, 2*size+1, 2*size+1)\n        img := image.NewPaletted(rect, palette)\n        colorIndex := uint8(i%len(palette-1) + 1)\n        for t := 0.0; t &lt; cycles*2*math.Pi; t += res {\n            x := math.Sin(t)\n            y := math.Sin(t*freq + phase)\n            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), colorIndex)\n        }\n        phase += 0.1\n        anim.Delay = append(anim.Delay, delay)\n        anim.Image = append(anim.Image, img)\n    }\n    gif.EncodeAll(os.Stdout, &amp;anim)\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-16-modify-the-lissajous-program-to-produce-images-in-multiple-colors-by-adding-more-values-to-palette-and-then-displaying-them-by-changing-the-third-argument-of-set-colorindex-in-some-interesting-way","title":"Exercise 1.6: Modify the Lissajous program to produce images in multiple colors by adding more values to palette and then displaying them by changing the third argument of Set-ColorIndex in some interesting way.","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nconst (\n    width, height = 600, 320\n    cells         = 100\n    xyrange       = 30.0\n)\n\nfunc main() {\n    fmt.Printf(\"&lt;svg xmlns='http://www.w3.org/2000/svg' style='stroke: grey; fill: white; stroke-width: 0.7' width='%d' height='%d'&gt;\", width, height)\n    for i := 0; i &lt; cells; i++ {\n        for j := 0; j &lt; cells; j++ {\n            ax, ay := corner(i+1, j)\n            bx, by := corner(i, j)\n            cx, cy := corner(i, j+1)\n            dx, dy := corner(i+1, j+1)\n            z := f((float64(i)/cells-0.5)*2*xyrange, (float64(j)/cells-0.5)*2*xyrange)\n            color := \"blue\"\n            if z &gt; 0 {\n                color = \"red\"\n            }\n            fmt.Printf(\"&lt;polygon points='%g,%g %g,%g %g,%g %g,%g' style='fill:%s'/&gt;\", ax, ay, bx, by, cx, cy, dx, dy, color)\n        }\n    }\n    fmt.Println(\"&lt;/svg&gt;\")\n}\n\nfunc corner(i, j int) (float64, float64) {\n    x := xyrange * (float64(i)/cells - 0.5)\n    y := xyrange * (float64(j)/cells - 0.5)\n    z := f(x, y)\n    sx := width/2 + (x-y)*math.Cos(math.Pi/6)*width/xyrange/2\n    sy := height/2 + (x+y)*math.Sin(math.Pi/6)*width/xyrange/2 - z*height*0.4\n    return sx, sy\n}\n\nfunc f(x, y float64) float64 {\n    r := math.Hypot(x, y)\n    return math.Sin(r) / r\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-17-the-function-call-iocopydst-src-reads-from-src-and-writes-to-dst-use-it-instead-of-ioutilreadall-to-copy-the-response-body-to-osstdout-without-requiring-a-buffer-large-enough-to-hold-the-entire-stream-be-sure-to-check-the-error-result-of-iocopy","title":"Exercise 1.7: The function call io.Copy(dst, src) reads from src and writes to dst. Use it instead of ioutil.ReadAll to copy the response body to os.Stdout without requiring a buffer large enough to hold the entire stream. Be sure to check the error result of io.Copy.","text":"<pre><code>package main\n\nimport (\n    \"io\"\n    \"net/http\"\n    \"os\"\n)\n\nfunc main() {\n    resp, _ := http.Get(os.Args[1])\n    io.Copy(os.Stdout, resp.Body)\n    resp.Body.Close()\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-18-modify-fetch-to-add-the-prefix-http-to-each-argument-url-if-it-is-missing-you-might-want-to-use-stringshasprefix","title":"Exercise 1.8: Modify fetch to add the prefix http:// to each argument URL if it is missing. You might want to use strings.HasPrefix.","text":"<pre><code>package main\n\nimport (\n    \"io\"\n    \"net/http\"\n    \"os\"\n    \"strings\"\n)\n\nfunc main() {\n    url := os.Args[1]\n    if !strings.HasPrefix(url, \"http://\") &amp;&amp; !strings.HasPrefix(url, \"https://\") {\n        url = \"http://\" + url\n    }\n    resp, _ := http.Get(url)\n    io.Copy(os.Stdout, resp.Body)\n    resp.Body.Close()\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-19-modify-fetch-to-also-print-the-http-status-code-found-in-respstatus","title":"Exercise 1.9: Modify fetch to also print the HTTP status code, found in resp.Status.","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"os\"\n)\n\nfunc main() {\n    resp, _ := http.Get(os.Args[1])\n    fmt.Println(resp.Status)\n    io.Copy(os.Stdout, resp.Body)\n    resp.Body.Close()\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-110-find-a-web-site-that-produces-a-large-amount-of-data-investigate-caching-by-running-fetchall-twice-in-succession-to-see-whether-the-reported-time-changes-much-do-you-get-the-same-content-each-time-modify-fetchall-to-print-its-output-to-a-file-so-it-can-be-examined","title":"Exercise 1.10: Find a web site that produces a large amount of data. Investigate caching by running fetchall twice in succession to see whether the reported time changes much. Do you get the same content each time? Modify fetchall to print its output to a file so it can be examined.","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n)\n\nfunc fetch(url string, ch chan&lt;- string) {\n    start := time.Now()\n    resp, _ := http.Get(url)\n    n, _ := io.Copy(io.Discard, resp.Body)\n    resp.Body.Close()\n    ch &lt;- fmt.Sprintf(\"%.2fs %7d %s\", time.Since(start).Seconds(), n, url)\n}\n\nfunc main() {\n    start := time.Now()\n    ch := make(chan string)\n    for _, url := range os.Args[1:] {\n        go fetch(url, ch)\n    }\n    for range os.Args[1:] {\n        fmt.Println(&lt;-ch)\n    }\n    fmt.Printf(\"%.2fs elapsed\\n\", time.Since(start).Seconds())\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-111-try-fetchall-with-longer-argument-lists-such-as-samples-from-the-top-million-web-sites-available-at-alexacom-how-does-the-program-behave-if-a-web-site-just-doesnt-respond-section-89-describes-mechanisms-for-coping-in-such-cases","title":"Exercise 1.11: Try fetchall with longer argument lists, such as samples from the top million web sites available at alexa.com. How does the program behave if a web site just doesn\u2019t respond? (Section 8.9 describes mechanisms for coping in such cases.)","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"os\"\n    \"time\"\n)\n\nfunc fetch(url string, ch chan&lt;- string) {\n    start := time.Now()\n    resp, err := http.Get(url)\n    if err != nil {\n        ch &lt;- err.Error()\n        return\n    }\n    n, _ := io.Copy(io.Discard, resp.Body)\n    resp.Body.Close()\n    ch &lt;- fmt.Sprintf(\"%.2fs %7d %s\", time.Since(start).Seconds(), n, url)\n}\n\nfunc main() {\n    ch := make(chan string)\n    for _, url := range os.Args[1:] {\n        go fetch(url, ch)\n    }\n    for range os.Args[1:] {\n        fmt.Println(&lt;-ch)\n    }\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-12-modify-the-lissajous-server-to-read-parameter-values-from-the-url-for-example-you-mig-ht-arrange-it-so-that-a-url-like-httplocalhost8000cycles20-sets-the-number-of-cycles-to-20-instead-of-the-default-5-use-the-strconvatoi-func-tion-to-convert-the-string-parameter-into-an-integer-you-can-see-its-documentation-wit-h-go-doc-strconvatoi","title":"Exercise 1.2: Modify the Lissajous server to read parameter values from the URL. For example, you mig ht arrange it so that a URL like http://localhost:8000/?cycles=20 sets the number of cycles to 20 instead of the default 5. Use the strconv.Atoi func tion to convert the string parameter into an integer. You can see its documentation wit h go doc strconv.Atoi.","text":"<pre><code>package main\n\nimport (\n    \"image\"\n    \"image/color\"\n    \"image/gif\"\n    \"math\"\n    \"math/rand\"\n    \"net/http\"\n)\n\nvar palette = []color.Color{color.White, color.Black}\n\nfunc lissajous(w http.ResponseWriter) {\n    const (\n        cycles  = 5\n        res     = 0.001\n        size    = 100\n        nframes = 64\n        delay   = 8\n    )\n    freq := rand.Float64() * 3.0\n    anim := gif.GIF{LoopCount: nframes}\n    phase := 0.0\n    for i := 0; i &lt; nframes; i++ {\n        rect := image.Rect(0, 0, 2*size+1, 2*size+1)\n        img := image.NewPaletted(rect, palette)\n        for t := 0.0; t &lt; cycles*2*math.Pi; t += res {\n            x := math.Sin(t)\n            y := math.Sin(t*freq + phase)\n            img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), 1)\n        }\n        phase += 0.1\n        anim.Delay = append(anim.Delay, delay)\n        anim.Image = append(anim.Image, img)\n    }\n    gif.EncodeAll(w, &amp;anim)\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        lissajous(w)\n    })\n    http.ListenAndServe(\":8000\", nil)\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#chapter-2","title":"Chapter 2","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-21-add-types-constants-and-functions-to-tempconv-for-processing-temperatures-in-the-kelvin-scale-where-zero-kelvin-is-27315c-and-a-difference-of-1k-has-the-same-magnitude-as-1c","title":"Exercise 2.1: Add types, constants, and functions to tempconv for processing temperatures in the Kelvin scale, where zero Kelvin is \u2212273.15\u00b0C and a difference of 1K has the same magnitude as 1\u00b0C.","text":"<pre><code>package tempconv\n\ntype Kelvin float64\n\nconst AbsoluteZeroC Celsius = -273.15\n\nfunc CToK(c Celsius) Kelvin {\n    return Kelvin(c - AbsoluteZeroC)\n}\n\nfunc KToC(k Kelvin) Celsius {\n    return Celsius(k) + AbsoluteZeroC\n}\n\nfunc FToK(f Fahrenheit) Kelvin {\n    return CToK(FToC(f))\n}\n\nfunc KToF(k Kelvin) Fahrenheit {\n    return CToF(KToC(k))\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-22-write-a-general-purpose-unit-conversion-program-analogous-to-cf-that-reads-numbers-from-its-command-line-arguments-or-from-the-standard-input-if-there-are-no-arguments-and-converts-each-number-into-units-like-temperature-in-celsius-and-fahren-heit-length-in-feet-and-meters-weig-ht-in-pounds-and-kilograms-and-the-like","title":"Exercise 2.2: Write a general-purpose unit-conversion program analogous to cf that reads numbers from its command-line arguments or from the standard input if there are no arguments, and converts each number into units like temperature in Celsius and Fahren heit, length in feet and meters, weig ht in pounds and kilograms, and the like.","text":"<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n)\n\ntype Celsius float64\ntype Fahrenheit float64\ntype Feet float64\ntype Meters float64\ntype Pounds float64\ntype Kilograms float64\n\nfunc CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }\nfunc FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }\n\nfunc FtToM(f Feet) Meters       { return Meters(f * 0.3048) }\nfunc MToFt(m Meters) Feet       { return Feet(m / 0.3048) }\n\nfunc LbToKg(p Pounds) Kilograms { return Kilograms(p * 0.45359237) }\nfunc KgToLb(k Kilograms) Pounds { return Pounds(k / 0.45359237) }\n\nfunc convert(v float64) {\n    c := Celsius(v)\n    f := Fahrenheit(v)\n    ft := Feet(v)\n    m := Meters(v)\n    lb := Pounds(v)\n    kg := Kilograms(v)\n\n    fmt.Printf(\"%g\u00b0C = %g\u00b0F, %g\u00b0F = %g\u00b0C\\n\", c, CToF(c), f, FToC(f))\n    fmt.Printf(\"%gft = %gm, %gm = %gft\\n\", ft, FtToM(ft), m, MToFt(m))\n    fmt.Printf(\"%glb = %gkg, %gkg = %glb\\n\", lb, LbToKg(lb), kg, KgToLb(kg))\n}\n\nfunc main() {\n    if len(os.Args) &gt; 1 {\n        for _, arg := range os.Args[1:] {\n            v, err := strconv.ParseFloat(arg, 64)\n            if err != nil {\n                continue\n            }\n            convert(v)\n        }\n        return\n    }\n\n    in := bufio.NewScanner(os.Stdin)\n    for in.Scan() {\n        v, err := strconv.ParseFloat(in.Text(), 64)\n        if err != nil {\n            continue\n        }\n        convert(v)\n    }\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-23-rewrite-popcount-to-use-a-loop-instead-of-a-single-expression-compare-the-performance-of-the-two-versions-section-114-shows-how-to-compare-the-per-formance-of-different-implementations-systematically","title":"Exercise 2.3: Rewrite PopCount to use a loop instead of a single expression. Compare the performance of the two versions. (Section 11.4 shows how to compare the per formance of different implementations systematically.)","text":"<pre><code>package popcount\n\nvar pc [256]byte\n\nfunc init() {\n    for i := range pc {\n        pc[i] = pc[i/2] + byte(i&amp;1)\n    }\n}\n\nfunc PopCountExpr(x uint64) int {\n    return int(pc[byte(x&gt;&gt;(0*8))] +\n        pc[byte(x&gt;&gt;(1*8))] +\n        pc[byte(x&gt;&gt;(2*8))] +\n        pc[byte(x&gt;&gt;(3*8))] +\n        pc[byte(x&gt;&gt;(4*8))] +\n        pc[byte(x&gt;&gt;(5*8))] +\n        pc[byte(x&gt;&gt;(6*8))] +\n        pc[byte(x&gt;&gt;(7*8))])\n}\n\nfunc PopCountLoop(x uint64) int {\n    n := 0\n    for i := 0; i &lt; 8; i++ {\n        n += int(pc[byte(x&gt;&gt;(i*8))])\n    }\n    return n\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-24-write-a-version-of-popcount-that-counts-bits-by-shifting-its-argument-through-64-bit-positions-testing-the-rightmost-bit-each-time-compare-its-performance-to-the-table-lookup-version","title":"Exercise 2.4: Write a version of PopCount that counts bits by shifting its argument through 64 bit positions, testing the rightmost bit each time. Compare its performance to the table-lookup version.","text":"<pre><code>package popcount\n\nfunc PopCountShift(x uint64) int {\n    n := 0\n    for i := 0; i &lt; 64; i++ {\n        if x&amp;1 == 1 {\n            n++\n        }\n        x &gt;&gt;= 1\n    }\n    return n\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#exercise-25-the-expression-xx-1-clears-the-rightmost-non-zero-bit-of-x-write-a-version-of-popcount-that-counts-bits-by-using-this-fact-and-assess-its-performance","title":"Exercise 2.5: The expression x&amp;(x-1) clears the rightmost non-zero bit of x. Write a version of PopCount that counts bits by using this fact, and assess its performance.","text":"<pre><code>package popcount\n\nfunc PopCountClear(x uint64) int {\n    n := 0\n    for x != 0 {\n        x &amp;= x - 1\n        n++\n    }\n    return n\n}\n</code></pre>"},{"location":"reading/books/read/the-go-programming-language/#chaper-3","title":"Chaper 3","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-31-if-the-function-f-returns-a-non-finite-float64-value-the-svg-file-will-contain-invalid-elements-although-many-svg-renderers-handle-this-gracefully-modify-the-program-to-skip-invalid-polygons","title":"Exercise 3.1: If the function f returns a non-finite float64 value, the SVG file will contain invalid  elements (although many SVG renderers handle this gracefully). Modify the program to skip invalid polygons. <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nconst (\n    width, height = 600, 320\n    cells         = 100\n    xyrange       = 30.0\n)\n\nfunc main() {\n    fmt.Printf(\"&lt;svg xmlns='http://www.w3.org/2000/svg' width='%d' height='%d'&gt;\", width, height)\n    for i := 0; i &lt; cells; i++ {\n        for j := 0; j &lt; cells; j++ {\n            ax, ay, ok1 := corner(i+1, j)\n            bx, by, ok2 := corner(i, j)\n            cx, cy, ok3 := corner(i, j+1)\n            dx, dy, ok4 := corner(i+1, j+1)\n            if !(ok1 &amp;&amp; ok2 &amp;&amp; ok3 &amp;&amp; ok4) {\n                continue\n            }\n            fmt.Printf(\"&lt;polygon points='%g,%g %g,%g %g,%g %g,%g'/&gt;\", ax, ay, bx, by, cx, cy, dx, dy)\n        }\n    }\n    fmt.Println(\"&lt;/svg&gt;\")\n}\n\nfunc corner(i, j int) (float64, float64, bool) {\n    x := xyrange * (float64(i)/cells - 0.5)\n    y := xyrange * (float64(j)/cells - 0.5)\n    z := f(x, y)\n    if math.IsNaN(z) || math.IsInf(z, 0) {\n        return 0, 0, false\n    }\n    sx := width/2 + (x-y)*math.Cos(math.Pi/6)*width/xyrange/2\n    sy := height/2 + (x+y)*math.Sin(math.Pi/6)*width/xyrange/2 - z*height*0.4\n    if math.IsNaN(sx) || math.IsNaN(sy) || math.IsInf(sx, 0) || math.IsInf(sy, 0) {\n        return 0, 0, false\n    }\n    return sx, sy, true\n}\n\nfunc f(x, y float64) float64 {\n    r := math.Hypot(x, y)\n    return math.Sin(r) / r\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-32-experiment-with-visualizations-of-other-functions-fro-m-the-math-package-can-you-produce-an-egg-box-moguls-or-a-saddle","title":"Exercise 3.2: Experiment with visualizations of other functions fro m the math package. Can you produce an egg box, moguls, or a saddle? <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nconst (\n    width, height = 600, 320\n    cells         = 100\n    xyrange       = 30.0\n    xyscale       = width / 2 / xyrange\n    zscale        = height * 0.4\n    angle         = math.Pi / 6\n)\n\nvar sin30, cos30 = math.Sin(angle), math.Cos(angle)\n\nfunc main() {\n    fmt.Printf(\"&lt;svg xmlns='http://www.w3.org/2000/svg' \"+\n        \"style='stroke: grey; fill: white; stroke-width: 0.7' \"+\n        \"width='%d' height='%d'&gt;\", width, height)\n    for i := 0; i &lt; cells; i++ {\n        for j := 0; j &lt; cells; j++ {\n            ax, ay, ok1 := corner(i+1, j)\n            bx, by, ok2 := corner(i, j)\n            cx, cy, ok3 := corner(i, j+1)\n            dx, dy, ok4 := corner(i+1, j+1)\n\n            if !ok1 || !ok2 || !ok3 || !ok4 {\n                continue\n            }\n\n            fmt.Printf(\"&lt;polygon points='%g,%g %g,%g %g,%g %g,%g'/&gt;\\n\",\n                ax, ay, bx, by, cx, cy, dx, dy)\n        }\n    }\n    fmt.Println(\"&lt;/svg&gt;\")\n}\n\nfunc corner(i, j int) (float64, float64, bool) {\n    x := xyrange * (float64(i)/cells - 0.5)\n    y := xyrange * (float64(j)/cells - 0.5)\n\n    z := f(x, y)\n\n    if !math.IsFinite(z) {\n        return 0, 0, false\n    }\n\n    sx := width/2 + (x-y)*cos30*xyscale\n    sy := height/2 + (x+y)*sin30*xyscale - z*zscale\n\n    if !math.IsFinite(sx) || !math.IsFinite(sy) {\n        return 0, 0, false\n    }\n\n    return sx, sy, true\n}\n\nfunc eggBox(x, y float64) float64 {\n    return math.Sin(x) + math.Sin(y)\n}\n\nfunc moguls(x, y float64) float64 {\n    return math.Sin(x) * math.Cos(y) * 10\n}\n\nfunc saddle(x, y float64) float64 {\n    return (x*x - y*y) / 300\n}\n\n// Use one of the above functions\nfunc f(x, y float64) float64 {\n    return saddle(x, y)\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-33-color-each-polygon-based-on-its-height-so-that-the-peaks-are-colored-redff0000-and-the-val-leys-blue-0000ff","title":"Exercise 3.3: Color each polygon based on its height, so that the peaks are colored red(#ff0000) and the val leys blue (#0000ff). <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nconst (\n    width, height = 600, 320\n    cells         = 100\n    xyrange       = 30.0\n    xyscale       = width / 2 / xyrange\n    zscale        = height * 0.4\n    angle         = math.Pi / 6\n)\n\nvar sin30, cos30 = math.Sin(angle), math.Cos(angle)\n\nfunc main() {\n    fmt.Printf(\"&lt;svg xmlns='http://www.w3.org/2000/svg' \"+\n        \"style='stroke: grey; stroke-width: 0.7' \"+\n        \"width='%d' height='%d'&gt;\", width, height)\n    for i := 0; i &lt; cells; i++ {\n        for j := 0; j &lt; cells; j++ {\n            ax, ay, az, ok1 := corner(i+1, j)\n            bx, by, bz, ok2 := corner(i, j)\n            cx, cy, cz, ok3 := corner(i, j+1)\n            dx, dy, dz, ok4 := corner(i+1, j+1)\n\n            if !ok1 || !ok2 || !ok3 || !ok4 {\n                continue\n            }\n\n            // Calculate average height of the polygon\n            avgZ := (az + bz + cz + dz) / 4\n            color := getColor(avgZ)\n\n            fmt.Printf(\"&lt;polygon points='%g,%g %g,%g %g,%g %g,%g' fill='%s'/&gt;\\n\",\n                ax, ay, bx, by, cx, cy, dx, dy, color)\n        }\n    }\n    fmt.Println(\"&lt;/svg&gt;\")\n}\n\nfunc corner(i, j int) (float64, float64, float64, bool) {\n    x := xyrange * (float64(i)/cells - 0.5)\n    y := xyrange * (float64(j)/cells - 0.5)\n\n    z := f(x, y)\n\n    if !math.IsFinite(z) {\n        return 0, 0, 0, false\n    }\n\n    sx := width/2 + (x-y)*cos30*xyscale\n    sy := height/2 + (x+y)*sin30*xyscale - z*zscale\n\n    if !math.IsFinite(sx) || !math.IsFinite(sy) {\n        return 0, 0, 0, false\n    }\n\n    return sx, sy, z, true\n}\n\nfunc getColor(z float64) string {\n    min, max := -1.0, 1.0\n    normalized := (z - min) / (max - min)\n\n    if normalized &lt; 0 {\n        normalized = 0\n    }\n    if normalized &gt; 1 {\n        normalized = 1\n    }\n\n    red := int(normalized * 255)\n    blue := int((1 - normalized) * 255)\n\n    return fmt.Sprintf(\"#%02x00%02x\", red, blue)\n}\n\nfunc f(x, y float64) float64 {\n    r := math.Hypot(x, y)\n    return math.Sin(r) / r\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-34-following-the-approach-of-the-lissajous-example-in-section-17-construct-a-web-server-that-computes-surfaces-and-writes-svg-data-to-the-client-the-server-must-set-the-content-type-header-like-this-wheadersetcontent-type-imagesvgxml","title":"Exercise 3.4: Following the approach of the Lissajous example in Section 1.7, construct a web server that computes surfaces and writes SVG data to the client. The server must set the Content-Type header like this: <code>w.Header().Set(\"Content-Type\", \"image/svg+xml\")</code> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"math\"\n    \"net/http\"\n)\n\nconst (\n    width, height = 600, 320\n    cells         = 100\n    xyrange       = 30.0\n    xyscale       = width / 2 / xyrange\n    zscale        = height * 0.4\n    angle         = math.Pi / 6\n)\n\nvar sin30, cos30 = math.Sin(angle), math.Cos(angle)\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    log.Fatal(http.ListenAndServe(\"localhost:8000\", nil))\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    w.Header().Set(\"Content-Type\", \"image/svg+xml\")\n    fmt.Fprintf(w, \"&lt;svg xmlns='http://www.w3.org/2000/svg' \"+\n        \"style='stroke: grey; fill: white; stroke-width: 0.7' \"+\n        \"width='%d' height='%d'&gt;\", width, height)\n    for i := 0; i &lt; cells; i++ {\n        for j := 0; j &lt; cells; j++ {\n            ax, ay, ok1 := corner(i+1, j)\n            bx, by, ok2 := corner(i, j)\n            cx, cy, ok3 := corner(i, j+1)\n            dx, dy, ok4 := corner(i+1, j+1)\n\n            if !ok1 || !ok2 || !ok3 || !ok4 {\n                continue\n            }\n\n            fmt.Fprintf(w, \"&lt;polygon points='%g,%g %g,%g %g,%g %g,%g'/&gt;\\n\",\n                ax, ay, bx, by, cx, cy, dx, dy)\n        }\n    }\n    fmt.Fprintln(w, \"&lt;/svg&gt;\")\n}\n\nfunc corner(i, j int) (float64, float64, bool) {\n    x := xyrange * (float64(i)/cells - 0.5)\n    y := xyrange * (float64(j)/cells - 0.5)\n\n    z := f(x, y)\n\n    if !math.IsFinite(z) {\n        return 0, 0, false\n    }\n\n    sx := width/2 + (x-y)*cos30*xyscale\n    sy := height/2 + (x+y)*sin30*xyscale - z*zscale\n\n    if !math.IsFinite(sx) || !math.IsFinite(sy) {\n        return 0, 0, false\n    }\n\n    return sx, sy, true\n}\n\nfunc f(x, y float64) float64 {\n    r := math.Hypot(x, y)\n    return math.Sin(r) / r\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-35-implement-a-full-color-mandelbrot-set-using-the-function-imagenewrgba-and-the-type-colorrgba-or-colorycbcr","title":"Exercise 3.5: Implement a full-color Mandelbrot set using the function image.NewRGBA and the type color.RGBA or color.YCbCr. <pre><code>package main\n\nimport (\n    \"image\"\n    \"image/color\"\n    \"image/png\"\n    \"math/cmplx\"\n    \"os\"\n)\n\nfunc main() {\n    const (\n        xmin, ymin, xmax, ymax = -2, -2, +2, +2\n        width, height          = 1024, 1024\n    )\n\n    img := image.NewRGBA(image.Rect(0, 0, width, height))\n    for py := 0; py &lt; height; py++ {\n        y := float64(py)/height*(ymax-ymin) + ymin\n        for px := 0; px &lt; width; px++ {\n            x := float64(px)/width*(xmax-xmin) + xmin\n            z := complex(x, y)\n            img.Set(px, py, mandelbrot(z))\n        }\n    }\n    png.Encode(os.Stdout, img)\n}\n\nfunc mandelbrot(z complex128) color.Color {\n    const iterations = 200\n    const contrast = 15\n\n    var v complex128\n    for n := uint8(0); n &lt; iterations; n++ {\n        v = v*v + z\n        if cmplx.Abs(v) &gt; 2 {\n            // Create colorful gradient based on iteration count\n            return color.RGBA{\n                R: 255 - contrast*n,\n                G: contrast * n,\n                B: 128 + contrast*n/2,\n                A: 255,\n            }\n        }\n    }\n    return color.Black\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-36-supersampling-is-a-technique-to-reduce-the-effect-of-pixelation-by-computing-the-color-value-at-several-points-wit-hin-each-pixel-and-taking-the-average-the-simplest-method-is-to-divide-each-pixel-into-four-subpixels-implement-it","title":"Exercise 3.6: Supersampling is a technique to reduce the effect of pixelation by computing the color value at several points wit hin each pixel and taking the average. The simplest method is to divide each pixel into four \u2018\u2018subpixels. \u2019\u2019 Implement it. <pre><code>package main\n\nimport (\n    \"image\"\n    \"image/color\"\n    \"image/png\"\n    \"math/cmplx\"\n    \"os\"\n)\n\nfunc main() {\n    const (\n        xmin, ymin, xmax, ymax = -2, -2, +2, +2\n        width, height          = 1024, 1024\n    )\n\n    img := image.NewRGBA(image.Rect(0, 0, width, height))\n    for py := 0; py &lt; height; py++ {\n        y := float64(py)/height*(ymax-ymin) + ymin\n        for px := 0; px &lt; width; px++ {\n            x := float64(px)/width*(xmax-xmin) + xmin\n            img.Set(px, py, supersample(x, y, width, height, xmin, xmax, ymin, ymax))\n        }\n    }\n    png.Encode(os.Stdout, img)\n}\n\nfunc supersample(x, y float64, width, height int, xmin, xmax, ymin, ymax float64) color.Color {\n    offsets := []float64{-0.25, 0.25}\n    var r, g, b, a uint32\n\n    dx := (xmax - xmin) / float64(width)\n    dy := (ymax - ymin) / float64(height)\n\n    for _, ox := range offsets {\n        for _, oy := range offsets {\n            z := complex(x+ox*dx, y+oy*dy)\n            c := mandelbrot(z)\n            r1, g1, b1, a1 := c.RGBA()\n            r += r1\n            g += g1\n            b += b1\n            a += a1\n        }\n    }\n\n    return color.RGBA{\n        R: uint8(r / 4 / 257),\n        G: uint8(g / 4 / 257),\n        B: uint8(b / 4 / 257),\n        A: uint8(a / 4 / 257),\n    }\n}\n\nfunc mandelbrot(z complex128) color.Color {\n    const iterations = 200\n    const contrast = 15\n\n    var v complex128\n    for n := uint8(0); n &lt; iterations; n++ {\n        v = v*v + z\n        if cmplx.Abs(v) &gt; 2 {\n            return color.RGBA{\n                R: 255 - contrast*n,\n                G: contrast * n,\n                B: 128 + contrast*n/2,\n                A: 255,\n            }\n        }\n    }\n    return color.Black\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-37-another-simple-fractal-uses-newtons-method-to-find-complex-solutions-to-a-function-such-as-z41-0-shade-each-starting-point-by-the-number-of-iterations-required-to-et-close-to-one-of-the-four-roots-color-each-point-by-the-root-it-approaches","title":"Exercise 3.7: Another simple fractal uses Newton\u2019s method to find complex solutions to a function such as z4\u22121 = 0. Shade each starting point by the number of iterations required to et close to one of the four roots. Color each point by the root it approaches. <pre><code>package main\n\nimport (\n    \"image\"\n    \"image/color\"\n    \"image/png\"\n    \"math/cmplx\"\n    \"os\"\n)\n\nfunc main() {\n    const (\n        xmin, ymin, xmax, ymax = -2, -2, +2, +2\n        width, height          = 1024, 1024\n    )\n\n    img := image.NewRGBA(image.Rect(0, 0, width, height))\n    for py := 0; py &lt; height; py++ {\n        y := float64(py)/height*(ymax-ymin) + ymin\n        for px := 0; px &lt; width; px++ {\n            x := float64(px)/width*(xmax-xmin) + xmin\n            z := complex(x, y)\n            img.Set(px, py, newton(z))\n        }\n    }\n    png.Encode(os.Stdout, img)\n}\n\nfunc f(z complex128) complex128 {\n    return z*z*z*z - 1\n}\n\nfunc fPrime(z complex128) complex128 {\n    return 4 * z * z * z\n}\n\nfunc newton(z complex128) color.Color {\n    const iterations = 50\n    const tolerance = 1e-6\n\n    roots := []complex128{\n        complex(1, 0),\n        complex(-1, 0),\n        complex(0, 1),\n        complex(0, -1),\n    }\n\n    colors := []color.RGBA{\n        {255, 0, 0, 255},   // Red\n        {0, 255, 0, 255},   // Green\n        {0, 0, 255, 255},   // Blue\n        {255, 255, 0, 255}, // Yellow\n    }\n\n    for n := 0; n &lt; iterations; n++ {\n        z = z - f(z)/fPrime(z)\n\n        for i, root := range roots {\n            if cmplx.Abs(z-root) &lt; tolerance {\n                shade := uint8(255 - (255 * n / iterations))\n                c := colors[i]\n                return color.RGBA{\n                    R: uint8(int(c.R) * int(shade) / 255),\n                    G: uint8(int(c.G) * int(shade) / 255),\n                    B: uint8(int(c.B) * int(shade) / 255),\n                    A: 255,\n                }\n            }\n        }\n    }\n\n    return color.Black\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-38-render-ing-fractals-at-high-zoom-levels-demands-great-arithmetic-precision-implement-the-same-fractal-using-four-different-representations-of-numbers-complex64-complex128-bigfloat-and-bigrat-the-latter-two-types-are-found-in-the-mathbig-package-float-uses-arbitrary-but-bounded-precision-floating-point-rat-uses-unbounded-precision-rational-numbers-how-do-they-comp-are-in-performance-and-memory-usage-at-what-zoom-levels-do-render-ing-artifacts-become-visible","title":"Exercise 3.8: Render ing fractals at high zoom levels demands great arithmetic precision. Implement the same fractal using four different representations of numbers: complex64, complex128, big.Float, and big.Rat. (The latter two types are found in the math/big package. Float uses arbitrary but bounded-precision floating-point; Rat uses unbounded-precision rational numbers.) How do they comp are in performance and memory usage? At what zoom levels do render ing artifacts become visible? <pre><code>package main\n\nimport (\n    \"image\"\n    \"image/color\"\n    \"image/png\"\n    \"math/big\"\n    \"math/cmplx\"\n    \"os\"\n)\n\nfunc mandelbrot64(z complex64) color.Color {\n    const iterations = 200\n    const contrast = 15\n\n    var v complex64\n    for n := uint8(0); n &lt; iterations; n++ {\n        v = v*v + z\n        if real(v)*real(v)+imag(v)*imag(v) &gt; 4 {\n            return color.Gray{255 - contrast*n}\n        }\n    }\n    return color.Black\n}\n\nfunc mandelbrot128(z complex128) color.Color {\n    const iterations = 200\n    const contrast = 15\n\n    var v complex128\n    for n := uint8(0); n &lt; iterations; n++ {\n        v = v*v + z\n        if cmplx.Abs(v) &gt; 2 {\n            return color.Gray{255 - contrast*n}\n        }\n    }\n    return color.Black\n}\n\nfunc mandelbrotBigFloat(zReal, zImag *big.Float) color.Color {\n    const iterations = 200\n    const contrast = 15\n\n    vReal := new(big.Float)\n    vImag := new(big.Float)\n\n    two := big.NewFloat(2)\n    four := big.NewFloat(4)\n\n    for n := uint8(0); n &lt; iterations; n++ {\n        vReal2 := new(big.Float).Mul(vReal, vReal)\n        vImag2 := new(big.Float).Mul(vImag, vImag)\n\n        newVReal := new(big.Float).Sub(vReal2, vImag2)\n        newVReal.Add(newVReal, zReal)\n\n        newVImag := new(big.Float).Mul(vReal, vImag)\n        newVImag.Mul(newVImag, two)\n        newVImag.Add(newVImag, zImag)\n\n        vReal = newVReal\n        vImag = newVImag\n\n        absSquared := new(big.Float).Add(vReal2, vImag2)\n        if absSquared.Cmp(four) &gt; 0 {\n            return color.Gray{255 - contrast*n}\n        }\n    }\n    return color.Black\n}\n\nfunc mandelbrotBigRat(zReal, zImag *big.Rat) color.Color {\n    const iterations = 200\n    const contrast = 15\n\n    vReal := new(big.Rat)\n    vImag := new(big.Rat)\n\n    four := big.NewRat(4, 1)\n    two := big.NewRat(2, 1)\n\n    for n := uint8(0); n &lt; iterations; n++ {\n        vReal2 := new(big.Rat).Mul(vReal, vReal)\n        vImag2 := new(big.Rat).Mul(vImag, vImag)\n\n        newVReal := new(big.Rat).Sub(vReal2, vImag2)\n        newVReal.Add(newVReal, zReal)\n\n        newVImag := new(big.Rat).Mul(vReal, vImag)\n        newVImag.Mul(newVImag, two)\n        newVImag.Add(newVImag, zImag)\n\n        vReal = newVReal\n        vImag = newVImag\n\n        absSquared := new(big.Rat).Add(vReal2, vImag2)\n        if absSquared.Cmp(four) &gt; 0 {\n            return color.Gray{255 - contrast*n}\n        }\n    }\n    return color.Black\n}\n\nfunc main() {\n    const (\n        xmin, ymin, xmax, ymax = -2, -2, +2, +2\n        width, height          = 1024, 1024\n    )\n\n    img := image.NewRGBA(image.Rect(0, 0, width, height))\n    for py := 0; py &lt; height; py++ {\n        y := float64(py)/height*(ymax-ymin) + ymin\n        for px := 0; px &lt; width; px++ {\n            x := float64(px)/width*(xmax-xmin) + xmin\n            z := complex(x, y)\n            img.Set(px, py, mandelbrot128(z))\n        }\n    }\n    png.Encode(os.Stdout, img)\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-39-write-a-web-server-that-renders-fractals-and-writes-the-image-data-to-the-client-allow-the-client-to-specify-the-x-y-and-zoom-values-as-parameters-to-the-http-request","title":"Exercise 3.9: Write a web server that renders fractals and writes the image data to the client. Allow the client to specify the x, y, and zoom values as parameters to the HTTP request. <pre><code>package main\n\nimport (\n    \"image\"\n    \"image/color\"\n    \"image/png\"\n    \"log\"\n    \"math/cmplx\"\n    \"net/http\"\n    \"strconv\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", handler)\n    log.Fatal(http.ListenAndServe(\"localhost:8000\", nil))\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    x, _ := strconv.ParseFloat(r.URL.Query().Get(\"x\"), 64)\n    y, _ := strconv.ParseFloat(r.URL.Query().Get(\"y\"), 64)\n    zoom, _ := strconv.ParseFloat(r.URL.Query().Get(\"zoom\"), 64)\n\n    if zoom == 0 {\n        zoom = 1\n    }\n\n    const (\n        width, height = 1024, 1024\n    )\n\n    scale := 4.0 / zoom\n    xmin := x - scale/2\n    xmax := x + scale/2\n    ymin := y - scale/2\n    ymax := y + scale/2\n\n    img := image.NewRGBA(image.Rect(0, 0, width, height))\n    for py := 0; py &lt; height; py++ {\n        yCoord := float64(py)/height*(ymax-ymin) + ymin\n        for px := 0; px &lt; width; px++ {\n            xCoord := float64(px)/width*(xmax-xmin) + xmin\n            z := complex(xCoord, yCoord)\n            img.Set(px, py, mandelbrot(z))\n        }\n    }\n\n    w.Header().Set(\"Content-Type\", \"image/png\")\n    png.Encode(w, img)\n}\n\nfunc mandelbrot(z complex128) color.Color {\n    const iterations = 200\n    const contrast = 15\n\n    var v complex128\n    for n := uint8(0); n &lt; iterations; n++ {\n        v = v*v + z\n        if cmplx.Abs(v) &gt; 2 {\n            return color.Gray{255 - contrast*n}\n        }\n    }\n    return color.Black\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-310-write-a-non-rec-ursive-version-of-comma-using-bytesbuffer-instead-of-string-concatenation","title":"Exercise 3.10: Write a non-rec ursive version of comma, using bytes.Buffer instead of string concatenation. <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n)\n\nfunc comma(s string) string {\n    var buf bytes.Buffer\n    n := len(s)\n\n    prefix := n % 3\n    if prefix == 0 {\n        prefix = 3\n    }\n\n    buf.WriteString(s[:prefix])\n\n    for i := prefix; i &lt; n; i += 3 {\n        buf.WriteByte(',')\n        buf.WriteString(s[i : i+3])\n    }\n\n    return buf.String()\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-311-enhance-comma-so-that-it-deals-correctly-with-floating-point-numbers-and-an-optional-sign","title":"Exercise 3.11: Enhance comma so that it deals correctly with floating-point numbers and an optional sign. <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc comma(s string) string {\n    var buf bytes.Buffer\n\n    start := 0\n    if s[0] == '+' || s[0] == '-' {\n        buf.WriteByte(s[0])\n        start = 1\n    }\n\n    parts := strings.Split(s[start:], \".\")\n    intPart := parts[0]\n\n    n := len(intPart)\n    prefix := n % 3\n    if prefix == 0 &amp;&amp; n &gt; 0 {\n        prefix = 3\n    }\n\n    if prefix &gt; 0 {\n        buf.WriteString(intPart[:prefix])\n    }\n\n    for i := prefix; i &lt; n; i += 3 {\n        if i &gt; 0 {\n            buf.WriteByte(',')\n        }\n        buf.WriteString(intPart[i : i+3])\n    }\n\n    if len(parts) &gt; 1 {\n        buf.WriteByte('.')\n        buf.WriteString(parts[1])\n    }\n\n    return buf.String()\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-312-write-a-function-that-rep-orts-whether-two-strings-are-anagrams-of-each-other-that-is-they-contain-the-same-letters-in-a-different-order","title":"Exercise 3.12: Write a function that rep orts whether two strings are anagrams of each other, that is, they contain the same letters in a different order. <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc areAnagrams(s1, s2 string) bool {\n    if len(s1) != len(s2) {\n        return false\n    }\n\n    counts := make(map[rune]int)\n\n    for _, r := range s1 {\n        counts[r]++\n    }\n\n    for _, r := range s2 {\n        counts[r]--\n        if counts[r] &lt; 0 {\n            return false\n        }\n    }\n\n    for _, count := range counts {\n        if count != 0 {\n            return false\n        }\n    }\n\n    return true\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-313-write-const-declarations-for-kb-mb-up-through-yb-as-compactly-as-you-can","title":"Exercise 3.13: Write const declarations for KB, MB, up through YB as compactly as you can. <pre><code>package main\n\nconst (\n    KB = 1000\n    MB = KB * 1000\n    GB = MB * 1000\n    TB = GB * 1000\n    PB = TB * 1000\n    EB = PB * 1000\n    ZB = EB * 1000\n    YB = ZB * 1000\n)\n\nconst (\n    _ = 1 &lt;&lt; (10 * iota)\n    KiB\n    MiB\n    GiB\n    TiB\n    PiB\n    EiB\n    ZiB\n    YiB\n)\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#chapter-4","title":"Chapter 4","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-41-write-a-function-that-counts-the-number-of-bits-that-are-different-in-two-sha256-hashes-see-popcount-from-section-262","title":"Exercise 4.1: Write a function that counts the number of bits that are different in two SHA256 hashes. (See PopCount from Section 2.6.2.) <pre><code>package main\n\nimport (\n    \"crypto/sha256\"\n    \"fmt\"\n)\n\nfunc hammingDistance(hash1, hash2 [32]byte) int {\n    count := 0\n    for i := 0; i &lt; 32; i++ {\n        xor := hash1[i] ^ hash2[i]\n        for xor != 0 {\n            xor &amp;= xor - 1\n            count++\n        }\n    }\n    return count\n}\n\nfunc main() {\n    s1 := \"hello\"\n    s2 := \"Hello\"\n\n    hash1 := sha256.Sum256([]byte(s1))\n    hash2 := sha256.Sum256([]byte(s2))\n\n    fmt.Printf(\"Hamming distance: %d bits\\n\", hammingDistance(hash1, hash2))\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-42-write-a-program-that-prints-the-sha256-hash-of-its-standard-input-by-default-but-supports-a-command-line-flag-to-print-the-sha384-or-sha512-hash-instead","title":"Exercise 4.2: Write a program that prints the SHA256 hash of its standard input by default but supports a command-line flag to print the SHA384 or SHA512 hash instead. <pre><code>package main\n\nimport (\n    \"crypto/sha256\"\n    \"crypto/sha512\"\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n)\n\nfunc main() {\n    hashType := flag.String(\"hash\", \"sha256\", \"hash type: sha256, sha384, or sha512\")\n    flag.Parse()\n\n    data, err := io.ReadAll(os.Stdin)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"error reading input: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    switch *hashType {\n    case \"sha256\":\n        fmt.Printf(\"%x\\n\", sha256.Sum256(data))\n    case \"sha384\":\n        fmt.Printf(\"%x\\n\", sha512.Sum384(data))\n    case \"sha512\":\n        fmt.Printf(\"%x\\n\", sha512.Sum512(data))\n    default:\n        fmt.Fprintf(os.Stderr, \"unsupported hash type: %s\\n\", *hashType)\n        os.Exit(1)\n    }\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-43-rewrite-reverse-to-use-an-array-pointer-instead-of-a-slice","title":"Exercise 4.3: Rewrite reverse to use an array pointer instead of a slice. <pre><code>package main\n\nimport \"fmt\"\n\nfunc reverse(arr *[5]int) {\n    for i, j := 0, len(arr)-1; i &lt; j; i, j = i+1, j-1 {\n        arr[i], arr[j] = arr[j], arr[i]\n    }\n}\n\nfunc main() {\n    a := [5]int{1, 2, 3, 4, 5}\n    fmt.Println(a)\n    reverse(&amp;a)\n    fmt.Println(a)\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-44-write-a-version-of-rotate-that-operates-in-a-single-pass","title":"Exercise 4.4: Write a version of rotate that operates in a single pass. <pre><code>package main\n\nimport \"fmt\"\n\nfunc rotate(s []int, n int) {\n    n = n % len(s)\n    if n &lt; 0 {\n        n += len(s)\n    }\n\n    reverse(s[:n])\n    reverse(s[n:])\n    reverse(s)\n}\n\nfunc reverse(s []int) {\n    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {\n        s[i], s[j] = s[j], s[i]\n    }\n}\n\nfunc main() {\n    s := []int{1, 2, 3, 4, 5}\n    rotate(s, 2)\n    fmt.Println(s)\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-45-write-an-in-place-function-to-eliminate-adjacent-duplicates-in-a-string-slice","title":"Exercise 4.5: Write an in-place function to eliminate adjacent duplicates in a []string slice. <pre><code>package main\n\nimport \"fmt\"\n\nfunc removeDuplicates(s []string) []string {\n    if len(s) == 0 {\n        return s\n    }\n\n    j := 0\n    for i := 1; i &lt; len(s); i++ {\n        if s[i] != s[j] {\n            j++\n            s[j] = s[i]\n        }\n    }\n    return s[:j+1]\n}\n\nfunc main() {\n    s := []string{\"a\", \"a\", \"b\", \"b\", \"b\", \"c\", \"a\", \"a\"}\n    fmt.Println(removeDuplicates(s))\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-46-write-an-in-place-function-that-squashes-each-run-of-adjacent-unicode-spaces-see-unicodeisspace-in-a-utf-8-enco-ded-byte-slice-into-a-single-ascii-space","title":"Exercise 4.6: Write an in-place function that squashes each run of adjacent Unicode spaces (see unicode.IsSpace) in a UTF-8-enco ded []byte slice into a single ASCII space. <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"unicode\"\n    \"unicode/utf8\"\n)\n\nfunc squashSpaces(s []byte) []byte {\n    out := s[:0]\n    inSpace := false\n\n    for i := 0; i &lt; len(s); {\n        r, size := utf8.DecodeRune(s[i:])\n        if unicode.IsSpace(r) {\n            if !inSpace {\n                out = append(out, ' ')\n                inSpace = true\n            }\n            i += size\n        } else {\n            out = append(out, s[i:i+size]...)\n            inSpace = false\n            i += size\n        }\n    }\n\n    return out\n}\n\nfunc main() {\n    s := []byte(\"hello   world\\t\\nfoo  bar\")\n    fmt.Printf(\"%q\\n\", s)\n    s = squashSpaces(s)\n    fmt.Printf(\"%q\\n\", s)\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-47-modify-reverse-to-reverse-the-characters-of-a-byte-slice-that-represents-a-utf-8-encoded-string-in-place-can-you-do-it-without-allocat-ing-new-memory","title":"Exercise 4.7: Modify reverse to reverse the characters of a []byte slice that represents a UTF-8-encoded string, in place. Can you do it without allocat ing new memory? <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc reverseUTF8(s []byte) {\n    for i := 0; i &lt; len(s); {\n        _, size := utf8.DecodeRune(s[i:])\n        reverse(s[i : i+size])\n        i += size\n    }\n    reverse(s)\n}\n\nfunc reverse(s []byte) {\n    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {\n        s[i], s[j] = s[j], s[i]\n    }\n}\n\nfunc main() {\n    s := []byte(\"Hello, \u4e16\u754c\")\n    fmt.Printf(\"%s\\n\", s)\n    reverseUTF8(s)\n    fmt.Printf(\"%s\\n\", s)\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-48-modify-charcount-to-count-letters-digits-and-so-on-in-their-unicode-categories-using-functions-like-unicodeisletter","title":"Exercise 4.8: Modify charcount to count letters, digits, and so on in their Unicode categories, using functions like unicode.IsLetter. <pre><code>.package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n    \"unicode\"\n)\n\nfunc main() {\n    counts := make(map[rune]int)\n    letters := 0\n    digits := 0\n    spaces := 0\n    marks := 0\n    punctuation := 0\n    symbols := 0\n    other := 0\n    invalid := 0\n\n    in := bufio.NewReader(os.Stdin)\n    for {\n        r, n, err := in.ReadRune()\n        if err == io.EOF {\n            break\n        }\n        if err != nil {\n            fmt.Fprintf(os.Stderr, \"charcount: %v\\n\", err)\n            os.Exit(1)\n        }\n        if r == unicode.ReplacementChar &amp;&amp; n == 1 {\n            invalid++\n            continue\n        }\n        counts[r]++\n\n        switch {\n        case unicode.IsLetter(r):\n            letters++\n        case unicode.IsDigit(r):\n            digits++\n        case unicode.IsSpace(r):\n            spaces++\n        case unicode.IsMark(r):\n            marks++\n        case unicode.IsPunct(r):\n            punctuation++\n        case unicode.IsSymbol(r):\n            symbols++\n        default:\n            other++\n        }\n    }\n\n    fmt.Println(\"Categories:\")\n    fmt.Printf(\"letters:\\t%d\\n\", letters)\n    fmt.Printf(\"digits:\\t\\t%d\\n\", digits)\n    fmt.Printf(\"spaces:\\t\\t%d\\n\", spaces)\n    fmt.Printf(\"marks:\\t\\t%d\\n\", marks)\n    fmt.Printf(\"punctuation:\\t%d\\n\", punctuation)\n    fmt.Printf(\"symbols:\\t%d\\n\", symbols)\n    fmt.Printf(\"other:\\t\\t%d\\n\", other)\n    if invalid &gt; 0 {\n        fmt.Printf(\"invalid:\\t%d\\n\", invalid)\n    }\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-49-write-a-program-wordfreq-to-rep-ort-the-frequency-of-each-word-in-an-input-text-file-call-inputsplitbufioscanwords-before-the-first-call-to-scan-to-break-the-input-into-words-instead-of-lines","title":"Exercise 4.9: Write a program wordfreq to rep ort the frequency of each word in an input text file. Call input.Split(bufio.ScanWords) before the first call to Scan to break the input into words instead of lines. <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"usage: wordfreq &lt;file&gt;\\n\")\n        os.Exit(1)\n    }\n\n    file, err := os.Open(os.Args[1])\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"wordfreq: %v\\n\", err)\n        os.Exit(1)\n    }\n    defer file.Close()\n\n    counts := make(map[string]int)\n    input := bufio.NewScanner(file)\n    input.Split(bufio.ScanWords)\n\n    for input.Scan() {\n        counts[input.Text()]++\n    }\n\n    if err := input.Err(); err != nil {\n        fmt.Fprintf(os.Stderr, \"wordfreq: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    for word, count := range counts {\n        fmt.Printf(\"%s\\t%d\\n\", word, count)\n    }\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-410-modify-issues-to-report-the-results-in-age-categories-say-less-than-a-month-old-less-than-a-year-old-and-more-than-a-year-old","title":"Exercise 4.10: Modify issues to report the results in age categories, say less than a month old, less than a year old, and more than a year old. <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"net/url\"\n    \"os\"\n    \"time\"\n)\n\nconst IssuesURL = \"https://api.github.com/search/issues\"\n\ntype IssuesSearchResult struct {\n    TotalCount int `json:\"total_count\"`\n    Items      []*Issue\n}\n\ntype Issue struct {\n    Number    int\n    HTMLURL   string `json:\"html_url\"`\n    Title     string\n    State     string\n    User      *User\n    CreatedAt time.Time `json:\"created_at\"`\n}\n\ntype User struct {\n    Login   string\n    HTMLURL string `json:\"html_url\"`\n}\n\nfunc SearchIssues(terms []string) (*IssuesSearchResult, error) {\n    q := url.QueryEscape(fmt.Sprintf(\"%v\", terms))\n    resp, err := http.Get(IssuesURL + \"?q=\" + q)\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"search query failed: %s\", resp.Status)\n    }\n\n    var result IssuesSearchResult\n    if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil {\n        return nil, err\n    }\n    return &amp;result, nil\n}\n\nfunc main() {\n    result, err := SearchIssues(os.Args[1:])\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    now := time.Now()\n    var lessThanMonth, lessThanYear, moreThanYear []*Issue\n\n    for _, item := range result.Items {\n        age := now.Sub(item.CreatedAt)\n        if age &lt; 30*24*time.Hour {\n            lessThanMonth = append(lessThanMonth, item)\n        } else if age &lt; 365*24*time.Hour {\n            lessThanYear = append(lessThanYear, item)\n        } else {\n            moreThanYear = append(moreThanYear, item)\n        }\n    }\n\n    fmt.Printf(\"%d issues:\\n\", result.TotalCount)\n\n    fmt.Println(\"\\nLess than a month old:\")\n    for _, item := range lessThanMonth {\n        fmt.Printf(\"#%-5d %9.9s %.55s\\n\", item.Number, item.User.Login, item.Title)\n    }\n\n    fmt.Println(\"\\nLess than a year old:\")\n    for _, item := range lessThanYear {\n        fmt.Printf(\"#%-5d %9.9s %.55s\\n\", item.Number, item.User.Login, item.Title)\n    }\n\n    fmt.Println(\"\\nMore than a year old:\")\n    for _, item := range moreThanYear {\n        fmt.Printf(\"#%-5d %9.9s %.55s\\n\", item.Number, item.User.Login, item.Title)\n    }\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-411-build-a-tool-that-lets-users-create-read-update-and-close-github-issues-from-the-command-line-invoking-their-preferred-text-editor-when-subst-antial-text-input-is-required","title":"Exercise 4.11: Build a tool that lets users create, read, update, and close GitHub issues from the command line, invoking their preferred text editor when subst antial text input is required. <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"os\"\n    \"os/exec\"\n    \"strings\"\n)\n\nconst APIBase = \"https://api.github.com\"\n\ntype Issue struct {\n    Number int    `json:\"number,omitempty\"`\n    Title  string `json:\"title\"`\n    Body   string `json:\"body\"`\n    State  string `json:\"state,omitempty\"`\n}\n\nfunc getToken() string {\n    token := os.Getenv(\"GITHUB_TOKEN\")\n    if token == \"\" {\n        fmt.Fprintln(os.Stderr, \"GITHUB_TOKEN environment variable not set\")\n        os.Exit(1)\n    }\n    return token\n}\n\nfunc editInEditor() (string, error) {\n    editor := os.Getenv(\"EDITOR\")\n    if editor == \"\" {\n        editor = \"vi\"\n    }\n\n    tmpfile, err := os.CreateTemp(\"\", \"issue-*.txt\")\n    if err != nil {\n        return \"\", err\n    }\n    defer os.Remove(tmpfile.Name())\n    tmpfile.Close()\n\n    cmd := exec.Command(editor, tmpfile.Name())\n    cmd.Stdin = os.Stdin\n    cmd.Stdout = os.Stdout\n    cmd.Stderr = os.Stderr\n\n    if err := cmd.Run(); err != nil {\n        return \"\", err\n    }\n\n    content, err := os.ReadFile(tmpfile.Name())\n    if err != nil {\n        return \"\", err\n    }\n\n    return string(content), nil\n}\n\nfunc createIssue(owner, repo, title, body string) error {\n    issue := Issue{Title: title, Body: body}\n    data, err := json.Marshal(issue)\n    if err != nil {\n        return err\n    }\n\n    url := fmt.Sprintf(\"%s/repos/%s/%s/issues\", APIBase, owner, repo)\n    req, err := http.NewRequest(\"POST\", url, bytes.NewBuffer(data))\n    if err != nil {\n        return err\n    }\n\n    req.Header.Set(\"Authorization\", \"token \"+getToken())\n    req.Header.Set(\"Content-Type\", \"application/json\")\n\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusCreated {\n        body, _ := io.ReadAll(resp.Body)\n        return fmt.Errorf(\"failed to create issue: %s\\n%s\", resp.Status, body)\n    }\n\n    fmt.Println(\"Issue created successfully\")\n    return nil\n}\n\nfunc readIssue(owner, repo, number string) error {\n    url := fmt.Sprintf(\"%s/repos/%s/%s/issues/%s\", APIBase, owner, repo, number)\n    req, err := http.NewRequest(\"GET\", url, nil)\n    if err != nil {\n        return err\n    }\n\n    req.Header.Set(\"Authorization\", \"token \"+getToken())\n\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"failed to read issue: %s\", resp.Status)\n    }\n\n    var issue Issue\n    if err := json.NewDecoder(resp.Body).Decode(&amp;issue); err != nil {\n        return err\n    }\n\n    fmt.Printf(\"Issue #%d\\nTitle: %s\\nState: %s\\n\\n%s\\n\", issue.Number, issue.Title, issue.State, issue.Body)\n    return nil\n}\n\nfunc updateIssue(owner, repo, number, title, body string) error {\n    issue := Issue{Title: title, Body: body}\n    data, err := json.Marshal(issue)\n    if err != nil {\n        return err\n    }\n\n    url := fmt.Sprintf(\"%s/repos/%s/%s/issues/%s\", APIBase, owner, repo, number)\n    req, err := http.NewRequest(\"PATCH\", url, bytes.NewBuffer(data))\n    if err != nil {\n        return err\n    }\n\n    req.Header.Set(\"Authorization\", \"token \"+getToken())\n    req.Header.Set(\"Content-Type\", \"application/json\")\n\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        body, _ := io.ReadAll(resp.Body)\n        return fmt.Errorf(\"failed to update issue: %s\\n%s\", resp.Status, body)\n    }\n\n    fmt.Println(\"Issue updated successfully\")\n    return nil\n}\n\nfunc closeIssue(owner, repo, number string) error {\n    issue := Issue{State: \"closed\"}\n    data, err := json.Marshal(issue)\n    if err != nil {\n        return err\n    }\n\n    url := fmt.Sprintf(\"%s/repos/%s/%s/issues/%s\", APIBase, owner, repo, number)\n    req, err := http.NewRequest(\"PATCH\", url, bytes.NewBuffer(data))\n    if err != nil {\n        return err\n    }\n\n    req.Header.Set(\"Authorization\", \"token \"+getToken())\n    req.Header.Set(\"Content-Type\", \"application/json\")\n\n    resp, err := http.DefaultClient.Do(req)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"failed to close issue: %s\", resp.Status)\n    }\n\n    fmt.Println(\"Issue closed successfully\")\n    return nil\n}\n\nfunc main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"usage: issues &lt;command&gt; [args]\\n\")\n        fmt.Fprintf(os.Stderr, \"commands:\\n\")\n        fmt.Fprintf(os.Stderr, \"  create &lt;owner/repo&gt; &lt;title&gt;\\n\")\n        fmt.Fprintf(os.Stderr, \"  read &lt;owner/repo&gt; &lt;number&gt;\\n\")\n        fmt.Fprintf(os.Stderr, \"  update &lt;owner/repo&gt; &lt;number&gt; &lt;title&gt;\\n\")\n        fmt.Fprintf(os.Stderr, \"  close &lt;owner/repo&gt; &lt;number&gt;\\n\")\n        os.Exit(1)\n    }\n\n    command := os.Args[1]\n\n    switch command {\n    case \"create\":\n        if len(os.Args) &lt; 4 {\n            fmt.Fprintln(os.Stderr, \"usage: issues create &lt;owner/repo&gt; &lt;title&gt;\")\n            os.Exit(1)\n        }\n        parts := strings.Split(os.Args[2], \"/\")\n        if len(parts) != 2 {\n            fmt.Fprintln(os.Stderr, \"repo must be in format owner/repo\")\n            os.Exit(1)\n        }\n        title := os.Args[3]\n        body, err := editInEditor()\n        if err != nil {\n            fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n            os.Exit(1)\n        }\n        if err := createIssue(parts[0], parts[1], title, body); err != nil {\n            fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n            os.Exit(1)\n        }\n\n    case \"read\":\n        if len(os.Args) &lt; 4 {\n            fmt.Fprintln(os.Stderr, \"usage: issues read &lt;owner/repo&gt; &lt;number&gt;\")\n            os.Exit(1)\n        }\n        parts := strings.Split(os.Args[2], \"/\")\n        if len(parts) != 2 {\n            fmt.Fprintln(os.Stderr, \"repo must be in format owner/repo\")\n            os.Exit(1)\n        }\n        if err := readIssue(parts[0], parts[1], os.Args[3]); err != nil {\n            fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n            os.Exit(1)\n        }\n\n    case \"update\":\n        if len(os.Args) &lt; 5 {\n            fmt.Fprintln(os.Stderr, \"usage: issues update &lt;owner/repo&gt; &lt;number&gt; &lt;title&gt;\")\n            os.Exit(1)\n        }\n        parts := strings.Split(os.Args[2], \"/\")\n        if len(parts) != 2 {\n            fmt.Fprintln(os.Stderr, \"repo must be in format owner/repo\")\n            os.Exit(1)\n        }\n        title := os.Args[4]\n        body, err := editInEditor()\n        if err != nil {\n            fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n            os.Exit(1)\n        }\n        if err := updateIssue(parts[0], parts[1], os.Args[3], title, body); err != nil {\n            fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n            os.Exit(1)\n        }\n\n    case \"close\":\n        if len(os.Args) &lt; 4 {\n            fmt.Fprintln(os.Stderr, \"usage: issues close &lt;owner/repo&gt; &lt;number&gt;\")\n            os.Exit(1)\n        }\n        parts := strings.Split(os.Args[2], \"/\")\n        if len(parts) != 2 {\n            fmt.Fprintln(os.Stderr, \"repo must be in format owner/repo\")\n            os.Exit(1)\n        }\n        if err := closeIssue(parts[0], parts[1], os.Args[3]); err != nil {\n            fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n            os.Exit(1)\n        }\n\n    default:\n        fmt.Fprintf(os.Stderr, \"unknown command: %s\\n\", command)\n        os.Exit(1)\n    }\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-412-the-popu-lar-web-comic-xkcd-has-a-json-interface-for-example-a-request-to-httpsxkcdcom571info0json-produces-a-detailed-description-of-comic-571-one-of-many-favorites-download-each-url-once-and-build-an-offline-index-write-a-tool-xkcd-that-using-this-index-prints-the-url-and-transcript-of-each-comic-that-matches-a-search-term-provided-on-the-command-line","title":"Exercise 4.12: The popu lar web comic xkcd has a JSON interface. For example, a request to https://xkcd.com/571/info.0.json produces a detailed description of comic 571, one of many favorites. Download each URL (once!) and build an offline index. Write a tool xkcd that, using this index, prints the URL and transcript of each comic that matches a search term provided on the command line. <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n)\n\nconst (\n    indexDir  = \"xkcd_index\"\n    maxComics = 3000\n)\n\ntype Comic struct {\n    Num        int    `json:\"num\"`\n    Title      string `json:\"title\"`\n    Transcript string `json:\"transcript\"`\n    Alt        string `json:\"alt\"`\n    Img        string `json:\"img\"`\n}\n\nfunc downloadComic(num int) (*Comic, error) {\n    url := fmt.Sprintf(\"https://xkcd.com/%d/info.0.json\", num)\n    resp, err := http.Get(url)\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"status: %s\", resp.Status)\n    }\n\n    var comic Comic\n    if err := json.NewDecoder(resp.Body).Decode(&amp;comic); err != nil {\n        return nil, err\n    }\n\n    return &amp;comic, nil\n}\n\nfunc saveComic(comic *Comic) error {\n    if err := os.MkdirAll(indexDir, 0755); err != nil {\n        return err\n    }\n\n    filename := filepath.Join(indexDir, fmt.Sprintf(\"%d.json\", comic.Num))\n    data, err := json.MarshalIndent(comic, \"\", \"  \")\n    if err != nil {\n        return err\n    }\n\n    return os.WriteFile(filename, data, 0644)\n}\n\nfunc loadComic(num int) (*Comic, error) {\n    filename := filepath.Join(indexDir, fmt.Sprintf(\"%d.json\", num))\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return nil, err\n    }\n\n    var comic Comic\n    if err := json.Unmarshal(data, &amp;comic); err != nil {\n        return nil, err\n    }\n\n    return &amp;comic, nil\n}\n\nfunc buildIndex() error {\n    fmt.Println(\"Building index...\")\n    for i := 1; i &lt;= maxComics; i++ {\n        filename := filepath.Join(indexDir, fmt.Sprintf(\"%d.json\", i))\n        if _, err := os.Stat(filename); err == nil {\n            continue\n        }\n\n        comic, err := downloadComic(i)\n        if err != nil {\n            continue\n        }\n\n        if err := saveComic(comic); err != nil {\n            return err\n        }\n\n        fmt.Printf(\"Downloaded comic %d\\n\", i)\n    }\n    fmt.Println(\"Index built successfully\")\n    return nil\n}\n\nfunc search(term string) error {\n    files, err := os.ReadDir(indexDir)\n    if err != nil {\n        return fmt.Errorf(\"index not found, run with 'build' command first\")\n    }\n\n    term = strings.ToLower(term)\n    found := false\n\n    for _, file := range files {\n        if filepath.Ext(file.Name()) != \".json\" {\n            continue\n        }\n\n        numStr := strings.TrimSuffix(file.Name(), \".json\")\n        num, err := strconv.Atoi(numStr)\n        if err != nil {\n            continue\n        }\n\n        comic, err := loadComic(num)\n        if err != nil {\n            continue\n        }\n\n        if strings.Contains(strings.ToLower(comic.Title), term) ||\n            strings.Contains(strings.ToLower(comic.Transcript), term) ||\n            strings.Contains(strings.ToLower(comic.Alt), term) {\n            fmt.Printf(\"Comic #%d: %s\\n\", comic.Num, comic.Title)\n            fmt.Printf(\"URL: https://xkcd.com/%d/\\n\", comic.Num)\n            fmt.Printf(\"Transcript: %s\\n\\n\", comic.Transcript)\n            found = true\n        }\n    }\n\n    if !found {\n        fmt.Println(\"No comics found matching:\", term)\n    }\n\n    return nil\n}\n\nfunc main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"usage: xkcd &lt;command&gt; [args]\\n\")\n        fmt.Fprintf(os.Stderr, \"commands:\\n\")\n        fmt.Fprintf(os.Stderr, \"  build          - build the index\\n\")\n        fmt.Fprintf(os.Stderr, \"  search &lt;term&gt;  - search for comics\\n\")\n        os.Exit(1)\n    }\n\n    command := os.Args[1]\n\n    switch command {\n    case \"build\":\n        if err := buildIndex(); err != nil {\n            fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n            os.Exit(1)\n        }\n    case \"search\":\n        if len(os.Args) &lt; 3 {\n            fmt.Fprintf(os.Stderr, \"usage: xkcd search &lt;term&gt;\\n\")\n            os.Exit(1)\n        }\n        if err := search(os.Args[2]); err != nil {\n            fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n            os.Exit(1)\n        }\n    default:\n        fmt.Fprintf(os.Stderr, \"unknown command: %s\\n\", command)\n        os.Exit(1)\n    }\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-413-the-json-based-web-service-of-the-open-movie-databas-e-lets-you-search-httpsomdbapicom-for-a-movie-by-name-and-download-its-poster-image-write-a-tool-poster-that-downloads-the-poster-image-for-the-movie-named-on-the-command-line","title":"Exercise 4.13: The JSON-based web service of the Open Movie Databas e lets you search https://omdbapi.com/ for a movie by name and download its poster image. Write a tool poster that downloads the poster image for the movie named on the command line. <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"net/url\"\n    \"os\"\n    \"strings\"\n)\n\nconst OMDBAPI = \"https://www.omdbapi.com/\"\n\ntype Movie struct {\n    Title  string `json:\"Title\"`\n    Poster string `json:\"Poster\"`\n}\n\nfunc searchMovie(title, apiKey string) (*Movie, error) {\n    params := url.Values{}\n    params.Add(\"t\", title)\n    params.Add(\"apikey\", apiKey)\n\n    resp, err := http.Get(OMDBAPI + \"?\" + params.Encode())\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"search failed: %s\", resp.Status)\n    }\n\n    var movie Movie\n    if err := json.NewDecoder(resp.Body).Decode(&amp;movie); err != nil {\n        return nil, err\n    }\n\n    if movie.Poster == \"\" || movie.Poster == \"N/A\" {\n        return nil, fmt.Errorf(\"no poster available for: %s\", title)\n    }\n\n    return &amp;movie, nil\n}\n\nfunc downloadPoster(posterURL, filename string) error {\n    resp, err := http.Get(posterURL)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"download failed: %s\", resp.Status)\n    }\n\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    _, err = io.Copy(file, resp.Body)\n    return err\n}\n\nfunc main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"usage: poster &lt;movie title&gt;\\n\")\n        os.Exit(1)\n    }\n\n    apiKey := os.Getenv(\"OMDB_API_KEY\")\n    if apiKey == \"\" {\n        fmt.Fprintf(os.Stderr, \"OMDB_API_KEY environment variable not set\\n\")\n        fmt.Fprintf(os.Stderr, \"Get a free API key from https://www.omdbapi.com/apikey.aspx\\n\")\n        os.Exit(1)\n    }\n\n    title := strings.Join(os.Args[1:], \" \")\n\n    movie, err := searchMovie(title, apiKey)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    filename := strings.ReplaceAll(movie.Title, \" \", \"_\") + \".jpg\"\n\n    if err := downloadPoster(movie.Poster, filename); err != nil {\n        fmt.Fprintf(os.Stderr, \"error downloading poster: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    fmt.Printf(\"Poster for '%s' saved as %s\\n\", movie.Title, filename)\n}\n</code></pre>","text":""},{"location":"reading/books/read/the-go-programming-language/#exercise-414-create-a-web-server-that-quer-ies-github-once-and-then-allows-navigation-of-the-list-of-bug-rep-orts-milestones-and-users","title":"Exercise 4.14: Create a web server that quer ies GitHub once and then allows navigation of the list of bug rep orts, milestones, and users. <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"net/url\"\n    \"os\"\n    \"strings\"\n)\n\nconst OMDBAPI = \"https://www.omdbapi.com/\"\n\ntype Movie struct {\n    Title  string `json:\"Title\"`\n    Poster string `json:\"Poster\"`\n}\n\nfunc searchMovie(title, apiKey string) (*Movie, error) {\n    params := url.Values{}\n    params.Add(\"t\", title)\n    params.Add(\"apikey\", apiKey)\n\n    resp, err := http.Get(OMDBAPI + \"?\" + params.Encode())\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return nil, fmt.Errorf(\"search failed: %s\", resp.Status)\n    }\n\n    var movie Movie\n    if err := json.NewDecoder(resp.Body).Decode(&amp;movie); err != nil {\n        return nil, err\n    }\n\n    if movie.Poster == \"\" || movie.Poster == \"N/A\" {\n        return nil, fmt.Errorf(\"no poster available for: %s\", title)\n    }\n\n    return &amp;movie, nil\n}\n\nfunc downloadPoster(posterURL, filename string) error {\n    resp, err := http.Get(posterURL)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"download failed: %s\", resp.Status)\n    }\n\n    file, err := os.Create(filename)\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    _, err = io.Copy(file, resp.Body)\n    return err\n}\n\nfunc main() {\n    if len(os.Args) &lt; 2 {\n        fmt.Fprintf(os.Stderr, \"usage: poster &lt;movie title&gt;\\n\")\n        os.Exit(1)\n    }\n\n    apiKey := os.Getenv(\"OMDB_API_KEY\")\n    if apiKey == \"\" {\n        fmt.Fprintf(os.Stderr, \"OMDB_API_KEY environment variable not set\\n\")\n        fmt.Fprintf(os.Stderr, \"Get a free API key from https://www.omdbapi.com/apikey.aspx\\n\")\n        os.Exit(1)\n    }\n\n    title := strings.Join(os.Args[1:], \" \")\n\n    movie, err := searchMovie(title, apiKey)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"error: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    filename := strings.ReplaceAll(movie.Title, \" \", \"_\") + \".jpg\"\n\n    if err := downloadPoster(movie.Poster, filename); err != nil {\n        fmt.Fprintf(os.Stderr, \"error downloading poster: %v\\n\", err)\n        os.Exit(1)\n    }\n\n    fmt.Printf(\"Poster for '%s' saved as %s\\n\", movie.Title, filename)\n}\n</code></pre>","text":""}]}